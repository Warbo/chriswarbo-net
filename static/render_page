#!/usr/bin/env bash
set -e
set -o pipefail

# Common options
IN_OPTIONS=(-t json)
OUT_OPTIONS=(-f json -s --mathml --template "$defaultTemplate")

# If the filename contains a date, provide it to the output template
if echo "$SOURCE" | grep -P "\d{4}-\d{2}-\d{2}" > /dev/null
then
    D=$(echo "$SOURCE" | grep -oP "\d{4}-\d{2}-\d{2}" | head -n1)
    OUT_OPTIONS+=(-M "date=\"$D\"")
fi

# If we're writing to a file, tell pandoc so it can guess the format. Also add
# the path from the output to the root as a variable so we can use relative
# links.
if [[ -n "$DEST" ]]
then
    OUT_OPTIONS+=(-o "$DEST")
fi

# See if we have a path to the source, for giving to pandoc
if [[ -n "$SOURCE_PATH" ]]
then
    OUT_OPTIONS+=(-M "path=\"$SOURCE_PATH\"")
fi

# If we're reading from a file, use it as pandoc's input, and provide the path
# as a variable for the output template.
if [[ -n "$SOURCE" ]]
then
    if [[ -z "$SOURCE_PATH" ]]
    then
        OUT_OPTIONS+=(-M "path=\"$SOURCE\"")
    fi
    IN_OPTIONS+=("$SOURCE") # This should go at the end; add extra options above
fi

# Capture programmatic input using cat, i.e. don't prompt the user if there's
# none available
if [ -t 0 ]
then
    INPUT=""
else
    INPUT=$(cat)
fi

echo "Running pandoc, capturing output for post-processing" 1>&2
echo "Pandoc options: ${IN_OPTIONS[@]}"                     1>&2

# We don't use pandoc's --filter option, as it buffers stderr which makes
# debugging harder
JSON=$(pandoc "${IN_OPTIONS[@]}") || {
    echo -e "Failed to convert to JSON. JSON:\n$JSON\n" 1>&2
    exit 1
}

echo "Applying panpipe" 1>&2
PIPED=$(echo "$JSON" | panpipe) || {
    echo -e "Failed to apply panpipe. JSON:\n$JSON\n\nPIPED:\n$PIPED\n" 1>&2
    exit 1
}
unset JSON

echo "Applying panhandle" 1>&2
HANDLED=$(echo "$PIPED" | panhandle) || {
    echo -e "Panhandle failed. PIPED:\n$PIPED\n\nHANDLED:\n$HANDLED\n" 1>&2
    exit 1
}
unset PIPED

echo "Converting from JSON" 1>&2
echo "Pandoc options: ${OUT_OPTIONS[@]}" 1>&2
OUTPUT=$(echo "$HANDLED" | pandoc "${OUT_OPTIONS[@]}") || {
    echo -e "Failed to convert back. JSON:\n$JSON\n\nOUTPUT:\n$OUTPUT\n" 1>&2
    exit 1
}
unset HANDLED

# If output was written to $DEST, read it back. This allows pandoc to determine
# the output format from the filename.
if [[ -n "$DEST" ]]
then
    if [[ -e "$DEST" ]]
    then
        OUTPUT=$(cat "$DEST")
        rm "$DEST"
    else
        echo "File '$DEST' wasn't created, aborting" 1>&2
        exit 1
    fi
fi

# Abort if our OUTPUT is empty
echo "$OUTPUT" | grep '[^ \n\t]' > /dev/null || {
    [[ -e "$DEST" ]] && rm "$DEST"
    echo "Output is empty, aborting" 1>&2
    exit 1
}

# Perform post-processing before outputting the result
CLEANED=$(echo "$OUTPUT" | cleanup)
unset OUTPUT

# Next, perform any custom postprocessing. This is specified by the file's YAML,
# and passed to us via the 'postprocessor' environment variable.
if [[ -n "$postprocessor" ]]
then
    echo "Running postprocessor '$postprocessor'" 1>&2
    POSTPROCESSED=$(echo "$CLEANED" | "$postprocessor")
else
    POSTPROCESSED="$CLEANED"
fi
unset CLEANED

# Send stdin to its final destination, either stdout or $DEST
if [[ -n "$DEST" ]]
then
    echo "Finished postprocessing, writing to '$DEST'" 1>&2
    echo "$POSTPROCESSED" > "$DEST"
else
    echo "Finished postprocessing, writing to stdout" 1>&2
    echo "$POSTPROCESSED"
fi
