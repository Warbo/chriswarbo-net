#!/usr/bin/env bash
set -e

# Common options
IN_OPTIONS=(-t json)
OUT_OPTIONS=(-f json -s --mathml --template "$defaultTemplate")

# If the filename contains a date, provide it to the output template
if echo "$SOURCE" | grep -P "\d{4}-\d{2}-\d{2}" > /dev/null
then
    D=$(echo "$SOURCE" | grep -oP "\d{4}-\d{2}-\d{2}" | head -n1)
    OUT_OPTIONS+=(-M date="$D")
fi

# If we're writing to a file, tell pandoc so it can guess the format. Also add
# the path from the output to the root as a variable so we can use relative
# links.
if [[ -n "$DEST" ]]
then
    OUT_OPTIONS+=(-o "$DEST")
fi

# See if we have a path to the source, for giving to pandoc
if [[ -n "$SOURCE_PATH" ]]
then
    OUT_OPTIONS+=(-M path="$SOURCE_PATH")
fi

# If we're reading from a file, use it as pandoc's input, and provide the path
# as a variable for the output template.
if [[ -n "$SOURCE" ]]
then
    if [[ -z "$SOURCE_PATH" ]]
    then
        OUT_OPTIONS+=(-M path="$SOURCE")
    fi
    IN_OPTIONS+=("$SOURCE") # This should go at the end; add extra options above
fi

# Capture programmatic input using cat, i.e. don't prompt the user if there's
# none available
if [ -t 0 ]
then
    INPUT=""
else
    INPUT=$(cat)
fi

echo "Running pandoc, capturing output for post-processing" 1>&2

# We don't use pandoc's --filter option, as it buffers stderr which makes
# debugging harder
OUTPUT=$(echo "$INPUT"             |
         pandoc "${IN_OPTIONS[@]}" |
         panpipe                   |
         panhandle                 |
         pandoc "${OUT_OPTIONS[@]}")

# If output was written to $DEST, read it back. This allows pandoc to determine
# the output format from the filename.
if [[ -n "$DEST" ]]
then
    if [[ -e "$DEST" ]]
    then
        OUTPUT=$(cat "$DEST")
        rm "$DEST"
    else
        echo "File '$DEST' wasn't created, aborting" 1>&2
        exit 1
    fi
fi

# Abort if our OUTPUT is empty
echo "$OUTPUT" | grep '[^ \n\t]' > /dev/null || {
    [[ -e "$DEST" ]] && rm "$DEST"
    echo "Output is empty, aborting" 1>&2
    exit 1
}

# Post-processing. This is slightly complicated, so we use more functions.

function getInput {
    # Get out input, either from stdin or $SOURCE
    if [[ -n "$SOURCE" ]]
    then
        cat "$SOURCE"
    else
        echo "$INPUT"
    fi
}

function writeOutput {
    # Send stdin to its final destination, either stdout or $DEST
    if [[ -n "$DEST" ]]
    then
        echo "Finished postprocessing, writing to '$DEST'" 1>&2
        cat > "$DEST"
    else
        echo "Finished postprocessing, writing to stdout" 1>&2
        cat
    fi
}

function getPostprocessor {
    # Check if YAML (between two "---" lines) specifies a postprocessor
    PP=""
    YAML=$(getInput | sed -n '/^---[-]*$/,/^---[-]*$/p')
    if [[ -n "$YAML" ]]
    then
        if LINE=$(echo "$YAML" | grep "postprocessor[ ]*:")
        then
            PP=$(echo "$LINE"                       |
                 sed -e 's/.*postprocessor[ ]*://g' |
                 sed -e 's/^ *//g'                  |
                 sed -e 's/ *$//g')
        fi
    fi
    echo "$PP"
}

function postprocess {
    CLEANED=$(cleanup)

    # Next, perform any custom postprocessing
    PP=$(getInput | getPostprocessor)
    if [[ -n "$PP" ]]
    then
        echo "Running postprocessor '$PP'" 1>&2
        echo "$CLEANED" | "$PP"
    else
        echo "$CLEANED"
    fi
}

# Perform post-processing before outputting the result
echo "$OUTPUT" | postprocess | writeOutput
