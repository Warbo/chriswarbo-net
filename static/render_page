#!/usr/bin/env bash

# Common options
IN_OPTIONS=(-t json)
OUT_OPTIONS=(-f json --template templates/default.html -s)

# If the filename contains a date, provide it to the output template
if echo "$SOURCE" | grep -P "blog/\d{4}-\d{2}-\d{2}" > /dev/null
then
    D=$(echo "$SOURCE" | grep -oP "blog/\d{4}-\d{2}-\d{2}" | grep -oP "\d{4}-\d{2}-\d{2}")
    OUT_OPTIONS+=(-M date="$D")
fi

# If we're writing to a file, tell pandoc so it can guess the format
if [[ -n "$DEST" ]]
then
    OUT_OPTIONS+=(-o "$DEST")
fi

# If we're reading from a file, use it as pandoc's input, and provide the path
# as a variable for the output template.
if [[ -n "$SOURCE" ]]
then
    OUT_OPTIONS+=(-M path="$SOURCE")
    IN_OPTIONS+=("$SOURCE") # This should go at the end; add extra options above
fi

# Capture programmatic input using cat, i.e. don't prompt the user if there's
# none available
if [ -t 0 ]
then
    INPUT=""
else
    INPUT=$(cat)
fi

echo "Running pandoc, capturing output for post-processing" >> /dev/stderr

# We don't use pandoc's --filter option, as it buffers stderr which makes
# debugging harder
OUTPUT=$(echo "$INPUT"             |
         pandoc "${IN_OPTIONS[@]}" |
         panpipe                   |
         panhandle                 |
         pandoc "${OUT_OPTIONS[@]}")

# If output was written to $DEST, read it back. This allows pandoc to determine
# the output format from the filename.
if [[ -n "$DEST" ]]
then
    OUTPUT=$(cat "$DEST")
    rm "$DEST"
fi

# Post-processing. This is slightly complicated, so we use more functions.

function getInput {
    # Get out input, either from stdin or $SOURCE
    if [[ -n "$SOURCE" ]]
    then
        cat "$SOURCE"
    else
        echo "$INPUT"
    fi
}

function writeOutput {
    # Send stdin to its final destination, either stdout or $DEST
    if [[ -n "$DEST" ]]
    then
        echo "Finished postprocessing, writing to '$DEST'" >> /dev/stderr
        cat > "$DEST"
    else
        echo "Finished postprocessing, writing to stdout" >> /dev/stderr
        cat
    fi
}

function getPostprocessor {
    # Check if YAML (between two "---" lines) specifies a postprocessor
    PP=""
    YAML=$(getInput | sed -n '/^---[-]*$/,/^---[-]*$/p')
    if [[ -n "$YAML" ]]
    then
        if LINE=$(echo "$YAML" | grep "postprocessor[ ]*:")
        then
            PP=$(echo "$LINE"                       |
                 sed -e 's/.*postprocessor[ ]*://g' |
                 sed -e 's/^ *//g'                  |
                 sed -e 's/ *$//g')
        fi
    fi
    echo "$PP"
}

function postprocess {
    CLEANED=$(./static/cleanup)

    # Next, perform any custom postprocessing
    PP=$(getInput | getPostprocessor)
    if [[ -n "$PP" ]]
    then
        echo "Running postprocessor '$PP'" >> /dev/stderr
        echo "$CLEANED" | "$PP"
    else
        echo "$CLEANED"
    fi
}

# Perform post-processing before outputting the result
echo "$OUTPUT" | postprocess | writeOutput
