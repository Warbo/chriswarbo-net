#!/usr/bin/env bash
set   -e
set   -o pipefail
shopt -s nullglob

if command -v ts > /dev/null && ts | grep queued | grep render > /dev/null
then
    echo "Another render is queued, deferring to that"
    exit 0
fi

# Set default parameter, if none supplied
[[ -n "$IPFS_PATH"    ]] || export IPFS_PATH=/var/lib/ipfs/.ipfs
[[ -n "$GIT_REPO_DIR" ]] || export GIT_REPO_DIR=/home/chris/Programming/repos

printf "Getting git HEADs..." 1>&2
function gitVersions() {
    echo "{"
    for D in "$GIT_REPO_DIR"/*.git
    do
        NAME=$(basename "$D" .git)
        REV=$(git ls-remote "$D" HEAD | cut -f1)
        printf '"%s":"%s" ' "$NAME" "$REV"
    done | sed -e 's/ *$//g' -e 's/ /, /g'
    echo "}"
}

REPO_REFS=$(gitVersions)
export REPO_REFS

# Speeds up latestGit
while read -r VAR
do
    N=$(echo "$VAR" | cut -f1)
    V=$(echo "$VAR" | cut -f2)
    export "$N"="$V"
done < <(gitRevEnvVars)
echo "Done" 1>&2

#printf "Getting IPFS keys..." 1>&2
#function ipfsKeys() {
#    while read -r PAIR
#    do
#        N=$(echo "$PAIR" | cut -d' ' -f2)
#        V=$(echo "$PAIR" | cut -d' ' -f1)
#        jq -n --arg n "$N" --arg v "$V" '{($n): $v}'
#    done < <(ipfs key list -l) | jq -s 'reduce .[] as $x ({}; . + $x)'
#}
#IPFS_KEYS=$(ipfsKeys)
#for D in "$GIT_REPO_DIR"/*.git
#do
#    N=$(basename "$D" .git)
#    echo "$IPFS_KEYS" | jq -e --arg n "$N" 'has($n)' > /dev/null || {
#        echo "No IPFS key found for git repo '$N':" 1>&2
#        echo "$IPFS_KEYS" 1>&2
#        exit 1
#    }
#done
#export IPFS_KEYS
#echo "Done" 1>&2

function build() {
    echo "Building '$1'" 1>&2
    BASE=$(dirname "$(readlink -f "$0")")
    nix-build --show-trace -A "$1" "$BASE/static/nix"
}

function doBuild() {
    build untestedSite
}

function buildAndTest() {
    build wholeSite
}

function addToIpfs() {
    build ipfsHash | tr -d '\n'
}

function pushToIpns() {
    echo "Checking for chriswarbo.net key" 1>&2
    ipfs key list | grep chriswarbonet > /dev/null || {
        echo "Couldn't find key for chriswarbo.net, can't push" 1>&2
        exit 1
    }

    HASHFILE=$(build ipfsHash)
    IPFSHASH=$(tr -d '\n' < "$HASHFILE")
    ipfs name publish -k chriswarbonet "$IPFSHASH"
}

function pushToWeb() {
    # Get raw files
    DIR=$(buildAndTest)

    echo "Pushing '$DIR' to Web root" 1>&2

    # Some explanation of these options:
    #   --ignore-times because Nix sets them all to 1970
    #   --checksum uses file content to determine what's changed, in lieu of the
    #     timestamp
    #   --delete removes any files on the destination which aren't in the source
    #   --progress tells us what it's up to
    #   --copy-unsafe-links causes absolute symlinks (or relative ones pointing
    #     outside the source tree) to be dereferenced and copied as files/dirs
    #   --exclude tells rsync to ignore a path, so it won't copy or delete it
    #   --archive causes directories and (safe) symlinks to be copied, and
    #     permissions, etc. to be preserved
    #   -e forces SSH to use a TTY, so sudo will work
    #   --rsync-path tells us what to run on the remote end, in this case we use
    #     sudo so we've got permission to write to /var/www. NOTE: If you use an
    #     SSH passphrase, this might cause it to be sent in the clear! We use
    #     keys so it's not an issue.
    copyToWeb --exclude /git --exclude /essays --exclude /repos \
              "$DIR/" chriswarbo.net:/var/www/html

    # Ensure symlinks are in place
    for PAIR in '/opt/git	/var/www/html/git'            \
                '/opt/repopages	/var/www/html/projects/repos' \
                '/var/www/html/projects	/var/www/html/essays' \
                '/var/www/html/projects/repos	/var/www/html/repos'
    do
        SRC=$(echo "$PAIR" | cut -f1)
        DST=$(echo "$PAIR" | cut -f2)
        if ssh chriswarbo.net "test -h '$DST'"
        then
            FOUND=$(ssh chriswarbo.net "readlink '$DST'")
            if [[ "x$FOUND" = "x$SRC" ]]
            then
                true
            else
                echo "WARNING: '$DST' points to '$FOUND', not '$SRC'" 1>&2
            fi
        else
            echo "WARNING: '$DST' is not a symlink to '$SRC'" 1>&2
        fi
    done
}

printf "Waiting for rendering lock..." 1>&2
(
  flock -x 200
  echo "lock aquired" 1>&2

  case "$1" in
      build)
          doBuild
          ;;

      test)
          buildAndTest
          ;;

      add)
          addToIpfs
          ;;

      ipfs)
          pushToIpns
          ;;

      web)
          pushToWeb
          ;;

      push)
          pushToWeb
          pushToIpns
          ;;

      *)
          echo "
Usage: $0 <build|test|add|ipfs|web|push>

build: Builds the HTML, CSS, etc. of the site. Outputs a directory containing
       the result.

test: Builds the site and runs tests on the result. Outputs a directory
      containing the result.

add: Adds the site to IPFS, outputting the resulting hash. This may take less
     space than performing a build, since we can re-use existing hashes without
     having to make a copy of the files they refer to.

ipfs: Performs an add, then attempts to publish the result to IPNS.

web: Builds the site and pushes pages to chriswarbo.net over SSH.

push: Push to ipfs and web.
          " 1>&2
          exit 1
          ;;
  esac
) 200>/tmp/blog.lock
