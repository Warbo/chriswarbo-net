---
title: A Whole New World
---
<div><p><span style="font-size: large;">I've found a couple of programming language projects which introduce the concept of "Worlds" as first-class citizens, although in slightly different ways.</span></p><p><span style="font-size: large;">In the land of Object Oriented programming, ie. Smalltalk and its derivatives, the concept of worlds is used to encapsulate the state of a program. All computation happens in a world, getting the current world is a simple function call, new worlds can be spawned from other worlds (OO-style inheritance applies to the worlds) and any world can be "committed to", ie. moving the rest of the computation into that world where it carries on. Essentially it gives programs an internal "undo" system, which can be used to try many possible execution paths safely. Some use cases are the following:</span></p><p><span style="font-size: large;"><code>We want to do </code></span><span style="font-size: large;"><code><em>goal</em></code></span><span style="font-size: large;"><code>, and there are X ways we could go about doing it.</code></span></p><p><span style="font-size: large;"><code>We split our computation into X new worlds, all running concurrently.</code></span></p><p><span style="font-size: large;"><code>In each world we attempt a different way of fulfilling </code></span><span style="font-size: large;"><code><em>goal</em></code></span><span style="font-size: large;"><code>.</code></span></p><p><span style="font-size: large;"><code>Once </code></span><span style="font-size: large;"><code><em>goal</em></code></span><span style="font-size: large;"><code> is achieved, all worlds except the current are deleted.</code></span></p><p><span style="font-size: large;"><code>The program continues to run in whichever world managed to satisfy </code></span><span style="font-size: large;"><code><em>goal</em></code></span><span style="font-size: large;"><code> first.</code></span></p><p><span style="font-size: large;">This way we guarantee that we reach </span><span style="font-size: large;"><em>goal</em></span><span style="font-size: large;"> using the fastest method (since we use every method), but this is achieved in an inherently distributed way: running multiple, concurrent attempts on one CPU in one machine may often give slower results than arbitrarily choosing one attempt and waiting for it to finish, even if it's not the fastest way possible. However, the nice thing about this use of worlds is that concurrent processing power can be utilised in an easy way without conflicts, and the thought required to understand it is very minimal; there's no scheduling, preempting, breadth-first/depth-first tradeoffs or anything like that. Just try everything and the fastest one will win by virtue of being the fastest, then move on to the next part of the program.</span></p><p><span style="font-size: large;">Another simple way of using worlds is to deal with potential errors (ie. exceptions). This is useful since exception handling is notoriously annoying to get right. In many programming languages and paradigms, when something fails (like attempting to contact a remote server for example) then the computation stops and an "exception" gets "thrown"/"raised", which means that whatever asked for that computation to happen is given an "exception" rather than whatever it requested. Receiving an exception is essentially a "GOTO" which jumps to whichever bit of code is assigned to deal with that type of exception (for example there might be SyntaxError, IOError, DivisionByZeroError, etc.). The problem with exceptions is that the catch-all nature of their handlers makes it difficult to determine where the exception came from. For example, we might write (in Python):</span></p><p><span style="font-size: large;"><code>import urllib2</code></span></p><p><span style="font-size: large;"><code>import time</code></span></p><p><span style="font-size: large;"><code>page1 = urllib2.urlopen('http://www.identi.ca/warbo')</code></span></p><p><span style="font-size: large;"><code>time.sleep(60)</code></span></p><p><span style="font-size: large;"><code>page2 = urllib2.urlopen('http://www.identi.ca/warbo')</code></span></p><p><span style="font-size: large;"><code>rate = post_difference(page1, page2)</code></span></p><p><span style="font-size: large;"><code>print str(rate)+" posts per minute"</code></span></p><p><span style="font-size: large;">This downloads my Identi.ca timeline and gives it the name </span><span style="font-size: large;"><code>page1</code></span><span style="font-size: large;">, then waits for a minute and does it again for </span><span style="font-size: large;"><code>page2</code></span><span style="font-size: large;">. Some arbitrary function called </span><span style="font-size: large;"><code>post_difference</code></span><span style="font-size: large;"> is run, presumably to count the difference in Identi.ca posts between </span><span style="font-size: large;"><code>page1</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>page2</code></span><span style="font-size: large;">, and the result is called </span><span style="font-size: large;"><code>rate</code></span><span style="font-size: large;">. We then write out a string of </span><span style="font-size: large;"><code>rate</code></span><span style="font-size: large;"> along with units. A problem with this is that the download may fail, and we haven't given any code to handle this, which means the program will exit with an error if this happens. To prevent this we can do:</span></p><p><span>import urllib2</span></p><p><span>import time</span></p><p><span>try:</span></p><p><span> page1 = urllib2.urlopen('http://www.identi.ca/warbo')</span></p><p><span> time.sleep(60)</span></p><p><span> page2 = urllib2.urlopen('http://www.identi.ca/warbo')</span></p><p><span> rate = post_difference(page1, page2)</span></p><p><span> print str(rate)+" posts per minute"</span></p><p><span>except:</span></p><p><span> del page1</span></p><p><span> del page2</span></p><p><span> del rate</span></p><p><span style="font-size: large;">Now if we get any type of exception in the three lines following </span><span style="font-size: large;"><code>try:</code></span><span style="font-size: large;"> then execution will jump to the </span><span style="font-size: large;"><code>except:</code></span><span style="font-size: large;"> block, otherwise the </span><span style="font-size: large;"><code>except:</code></span><span style="font-size: large;"> block will just be skipped. Since having one page is useless without the other, and keeping such useless objects accessible prevents the garbage collector from freeing up the memory they take up, we use this exception block to simply delete the </span><span style="font-size: large;"><code>page1</code></span><span style="font-size: large;">, </span><span style="font-size: large;"><code>page2</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>rate</code></span><span style="font-size: large;"> objects. Unfortunately there's actually a problem with this code too! Since we delete </span><span style="font-size: large;"><code>page1</code></span><span style="font-size: large;">, </span><span style="font-size: large;"><code>page2</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>rate</code></span><span style="font-size: large;">, and the exception might happen before those objects are defined (for example if an exception occurs whilst trying to download </span><span style="font-size: large;"><code>page1</code></span><span style="font-size: large;">, then the download of </span><span style="font-size: large;"><code>page2</code></span><span style="font-size: large;"> and calculation of </span><span style="font-size: large;"><code>rate</code></span><span style="font-size: large;"> will never occur), then we might be asking to delete things which don't exist, which causes an exception! The example I've chosen here is meant to be slightly pathological, since the two dangerous operations we're doing (downloading my Identi.ca timeline) are exactly the same apart from binding name and line number. This means we can't, for example, have one </span><span style="font-size: large;"><code>except:</code></span><span style="font-size: large;"> block to deal with network errors and another to deal with some other exception type, since they both have the same exception possibilities. There are various ways of doing this correctly (using multiple </span><span style="font-size: large;"><code>try:</code></span><span style="font-size: large;">/</span><span style="font-size: large;"><code>except:</code></span><span style="font-size: large;"> blocks, using temporary booleans to store whether each bit succeeded or not, etc.), but none of them are as intuitive as the way shown above. Using worlds, however, makes things easy, since we can encapsulate all of the side-effects of our attempts in a child world and simply delete the world if we fail, ie. something like the following (although I've made up the syntax since it doesn't exist for Python ;):</span></p><p><span style="font-size: large;"><code>import urllib2</code></span></p><p><span style="font-size: large;"><code>import time</code></span></p><p><span style="font-size: large;"><code>child_world = get_world().spawn()</code></span></p><p><span style="font-size: large;"><code>use_world(child_world)</code></span></p><p><span style="font-size: large;"><code>try:</code></span></p><p><span style="font-size: large;"><code>  page1 = urllib2.urlopen('http://www.identi.ca/warbo')</code></span></p><p><span style="font-size: large;"><code>  time.sleep(60)</code></span></p><p><span style="font-size: large;"><code>  page2 = urllib2.urlopen('http://www.identi.ca/warbo')</code></span></p><p><span style="font-size: large;"><code>  rate = post_difference(page1, page2)</code></span></p><p><span style="font-size: large;"><code>  print str(rate)+" posts per minute"</code></span></p><p><span style="font-size: large;"><code>  child_world.commit()</code></span></p><p><span style="font-size: large;"><code>except:</code></span></p><p><span style="font-size: large;"><code>  del child_world</code></span></p><p><span style="font-size: large;">Here we know that every side-effect (including the definition of new objects) will be contained in </span><span style="font-size: large;"><code>child_world</code></span><span style="font-size: large;">, so if we fail we can simply delete it. Of course, there's nothing to stop a language using worlds directly for its exception handling (say by destroying world after world until one is reached that handles the exception, rather than just destroying stack frames), but Python couldn't do this as it would break its behaviour and thus existing code.</span></p><p><span style="font-size: large;">Another suggestion for using worlds is for </span><span style="font-size: large;"><em>namespaces</em></span><span style="font-size: large;"> and module systems. In Python, code from other files is made accessible to a program by using a line like:</span></p><p><span style="font-size: large;"><code>import xyz</code></span></p><p><span style="font-size: large;">Which makes the contents of the module </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> available to the program, so that you can run, say:</span></p><p><span style="font-size: large;"><code>import xyz</code></span></p><p><span style="font-size: large;"><code>xyz.some_function(a, b, xyz.something)</code></span></p><p><span style="font-size: large;">The </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> module has its own </span><span style="font-size: large;"><em>namespace</em></span><span style="font-size: large;">, so that everything it contains is only accessible if you put </span><span style="font-size: large;"><code>xyz.</code></span><span style="font-size: large;"> before the name (and namespaces can be nested, so we could say </span><span style="font-size: large;"><code>xyz.abc.something.foo()</code></span><span style="font-size: large;"> ). It's similar to a Web site address but using full stops instead of slashes. This makes sure that whatever </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> contains, it won't mess up your program, since you can call something </span><span style="font-size: large;"><code>a</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> can call something </span><span style="font-size: large;"><code>a</code></span><span style="font-size: large;">, but they won't conflict in your program since your </span><span style="font-size: large;"><code>a</code></span><span style="font-size: large;"> is called </span><span style="font-size: large;"><code>a</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;">'s </span><span style="font-size: large;"><code>a</code></span><span style="font-size: large;"> is called </span><span style="font-size: large;"><code>xyz.a</code></span><span style="font-size: large;">. There is also </span><span style="font-size: large;"><em>namespace injection</em></span><span style="font-size: large;">, which takes things from a module and puts them in the current namespace, for example:</span></p><p><span style="font-size: large;"><code>from xyz import a, b, some_function</code></span></p><p><span style="font-size: large;">Now those three things we've imported will be available without the </span><span style="font-size: large;"><code>xyz.</code></span><span style="font-size: large;"> in front of them. However, this is acceptable since we've explicitly defined which bits of </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> we want, so it should be obvious to us if this will cause any conflicts without having to know what's in </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;">. However, in Python there is a dangerous and frowned-upon wildcard for namespace injection, which looks like:</span></p><p><span style="font-size: large;"><code>from xyz import *</code></span></p><p><span style="font-size: large;">This will make everything from </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> available in your program without having to put </span><span style="font-size: large;"><code>xyz.</code></span><span style="font-size: large;"> before it. Since this line doesn't specify any names, the only way we could know what this is going to do would be to manually read the code in </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> or do:</span></p><p><span style="font-size: large;"><code>import xyz</code></span></p><p><span style="font-size: large;"><code>dir(xyz)</code></span></p><p><span style="font-size: large;">But this would still only work for that particular version of </span><span style="font-size: large;"><code>xyz</code></span><span style="font-size: large;"> you're using. Other people might be using different versions, and future updates might change which names it uses internally. This is often called</span><span style="font-size: large;"><em> polluting the namespace</em></span><span style="font-size: large;">, since you end up with crap that gets in the way.</span></p><p><span style="font-size: large;">By defining modules in their own worlds, we essentially get the advantage of namespaces (ie. worlds can be used as a namespace implementation), plus we can make and destroy namespaces at any time. For example:</span></p><p><span style="font-size: large;"><code>import xyz</code></span></p><p><span style="font-size: large;"><code>abc = xyz.some_function(12)</code></span></p><p><span style="font-size: large;"><code>g = abc+2</code></span></p><p><span style="font-size: large;"><code>switch_world(get_world().spawn_world())</code></span></p><p><span style="font-size: large;"><code>import abc</code></span></p><p><span style="font-size: large;"><code>abc.some_other_function(g)</code></span></p><p><span style="font-size: large;"><code>destroy_world()</code></span></p><p><span style="font-size: large;"><code>print str(abc)</code></span></p><p><span style="font-size: large;">The final line will display the value we called </span><span style="font-size: large;"><code>abc</code></span><span style="font-size: large;"> in the second line, regardless of what importing a module called </span><span style="font-size: large;"><code>abc</code></span><span style="font-size: large;"> did to mess up our namespace later on.</span></p><p><span style="font-size: large;">Functionally</span></p><p><span style="font-size: large;">In the world of functional programming, there is no need to encapsulate side-effects, since all purely functional programs are side-effect free (ie. if something is true somewhere, then it is true everywhere, like regular Maths notation). The concept of worlds here is slightly different, since worlds are passed around as arguments to functions rather than acting like a stack, but the idea of encapsulating state remains the same.</span></p><p><span style="font-size: large;">In a functional language a function, let's call it </span><span style="font-size: large;"><code>increment_answer</code></span><span style="font-size: large;">, can be given another function as an argument. This is known as a </span><span style="font-size: large;"><em>higher-order function</em></span><span style="font-size: large;">, and as far as the language is concerned, </span><span style="font-size: large;"><code>increment_answer</code></span><span style="font-size: large;"> is a perfectly valid function just waiting to act on something. To put some tangible code for this, we can say:</span></p><p><span style="font-size: large;"><code>square(x) ::= x*x</code></span></p><p><span style="font-size: large;"><code>increment(x) ::= x+1</code></span></p><p><span style="font-size: large;"><code>increment_answer(f, x) ::= increment(f(x))</code></span></p><p><span style="font-size: large;"><code>square_plus_one(x) ::= increment_answer(square, x)</code></span></p><p><span style="font-size: large;">Even though I've made up this syntax, I'm sure it is pretty straightforward. The interesting thing to note, however, is that at no point in the above is </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;"> ever defined. We can assume that </span><span style="font-size: large;"><code>*</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>+</code></span><span style="font-size: large;"> are defined somewhere in this made-up language, but </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;"> only acts as a placeholder; it can stand for anything and the definitions given above always be valid, no matter what the functions do. So far so good, and if you've used a language like Ruby or Python you probably know of higher order functions already. So let's spice things up a bit:</span></p><p><span style="font-size: large;"><code>max(x, y) ::= x if x &gt; y else y</code></span></p><p><span style="font-size: large;"><code>allow_positive(x) ::= max(0, x)</code></span></p><p><span style="font-size: large;">This probably seems straightforward too: </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> will give the larger of its two arguments whilst </span><span style="font-size: large;"><code>allow_positive</code></span><span style="font-size: large;"> will return its argument if it's positive, or else zero. Here we've been implying numbers, however. So let's look at what happens if we give everything a type:</span></p><p><span style="font-size: large;"><code>square(number x) ::= x*x</code></span></p><p><span style="font-size: large;"><code>type(square) = number -&gt; number</code></span></p><p><span style="font-size: large;"><code>increment(number x) ::= x+1</code></span></p><p><span style="font-size: large;"><code>type(increment) = number -&gt; number</code></span></p><p><span style="font-size: large;"><code>increment_answer(number -&gt; number f, number x) ::= increment(f(x))</code></span></p><p><span style="font-size: large;"><code>type(increment_answer) = number -&gt; number -&gt; number -&gt; number</code></span></p><p><span style="font-size: large;"><code>max(number x, number y) ::= x if x &gt; y else y</code></span></p><p><span style="font-size: large;"><code>type(max) = number -&gt; number -&gt; number</code></span></p><p><span style="font-size: large;"><code>allow_positive(number x) ::= max(0, x)</code></span></p><p><span style="font-size: large;"><code>type(allow_positive) = number -&gt; number</code></span></p><p><span style="font-size: large;">The type notation I've used means that the left-hand-side is the input and the right-hand-side is the output, so that the type </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;"> is a function that, when given a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">, will return a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">. Easy, yes? Well what about the type of </span><span style="font-size: large;"><code>increment_answer</code></span><span style="font-size: large;">? It has two arguments, the first is a function which must accept a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> (since we pass it </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;">) and return a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> (since </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> takes a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">), so the type of its first argument must be a function </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;">. Its second argument is just a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">. Giving it both of these will return a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">, so its type is </span><span style="font-size: large;"><code>number -&gt; number -&gt; number -&gt; number</code></span><span style="font-size: large;">. That may seem a little confusing (where does "left" end and "right" begin?), so to consider a slightly simpler, non-higher order example let's take a look at </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;">.</span></p><p><span style="font-size: large;">There are two arrows in the type of </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;">, and it's not completely clear that both of the left ones are the inputs </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>y</code></span><span style="font-size: large;">. Why have I made the confusing mistake of putting </span><span style="font-size: large;"><code>number -&gt; number -&gt; number</code></span><span style="font-size: large;"> instead of something like </span><span style="font-size: large;"><code>(number -&gt; number) -&gt; number</code></span><span style="font-size: large;">? Well it's because of </span><span style="font-size: large;"><em>Currying</em></span><span style="font-size: large;">. The type of </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> is </span><span style="font-size: large;"><code>number -&gt; number -&gt; number</code></span><span style="font-size: large;">, with the left as input and the right as output, as I said earlier, but attempting to segregate arguments and returns, for example with brackets, is futile: thanks to Currying it's completely up to you what you consider to be the left and right! The obvious type from the function definition would be two </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">s in to get one </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> out, but it's also valid to say that it takes a single </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> in and gives out a </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;">. But what the hell kind of return value is that? Well, if you look at the other types I've scattered around there, it should be obvious that </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;"> is a function which takes a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> and returns a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">. So </span><span style="font-size: large;"><code>max(5)</code></span><span style="font-size: large;"> is a perfectly valid function call, and will return a function for us! So what does such a function do? In this case it will give the larger of its argument or 5, so we can say:</span></p><p><span style="font-size: large;"><code>five_or_above ::= max(5)</code></span></p><p><span style="font-size: large;"><code>type(five_or_above) = number -&gt; number</code></span></p><p><span style="font-size: large;"><code>five_or_above(12) = 12</code></span></p><p><span style="font-size: large;"><code>five_or_above(3) = 5</code></span></p><p><span style="font-size: large;"><code>type(10) = number</code></span></p><p><span style="font-size: large;"><code>type(five_or_above(10)) = number</code></span></p><p><span style="font-size: large;">It basically acts like </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> but with the first argument 'filled in' with a 5. This actually allows us to use a simpler definition of our </span><span style="font-size: large;"><code>allow_positive</code></span><span style="font-size: large;"> function, since we can say:</span></p><p><span style="font-size: large;"><code>allow_positive ::= max(0)</code></span></p><p><span style="font-size: large;"><code>type(allow_positive) = number -&gt; number</code></span></p><p><span style="font-size: large;">This will behave in exactly the same way as the previous definition.</span></p><p><span style="font-size: large;">What about the other way around? What happens if we give </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> an argument of </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;"> (ie. a function from </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">s to </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">s)? Do we get the remaining, right-most </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> as a return? Not quite. It's perfectly valid to call </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> with a function, for example:</span></p><p><span style="font-size: large;"><code>max(number x, number y) ::= x if x &gt; y else y</code></span></p><p><span style="font-size: large;"><code>type(max) = number -&gt; number -&gt; number</code></span></p><p><span style="font-size: large;"><code>increment(number x) ::= x+1</code></span></p><p><span style="font-size: large;"><code>type(increment) = number -&gt; number</code></span></p><p><span style="font-size: large;"><code>result ::= max(increment)</code></span></p><p><span style="font-size: large;"><code>type(result) = number -&gt; number</code></span></p><p><span style="font-size: large;">Hmm, we seem to have received a function back rather than a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">. Why's that? Well it's because the function we gave to </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;">, namely </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> (for lack of a better example), requires an argument in order to do anything. Calling </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> of </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> only makes sense when we give </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> something to add one to! Thus </span><span style="font-size: large;"><code>max(increment)</code></span><span style="font-size: large;"> gives us a function which can be thought of as follows:</span></p><p><span style="font-size: large;"><code>max(increment) = x if x &gt; x+1 else x+1</code></span></p><p><span style="font-size: large;"><code>type(max(increment)) = number -&gt; number</code></span></p><p><span style="font-size: large;">In other words it takes a </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> in for the first argument of </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;">, namely </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;">, then sends that to </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> to find out what to use for </span><span style="font-size: large;"><code>y</code></span><span style="font-size: large;"> (which will be </span><span style="font-size: large;"><code>x+1</code></span><span style="font-size: large;">, since that's what </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> returns), then runs </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;"> of </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>y</code></span><span style="font-size: large;">, ie. of </span><span style="font-size: large;"><code>x</code></span><span style="font-size: large;"> and </span><span style="font-size: large;"><code>x+1</code></span><span style="font-size: large;"> (which incidentally will always behave like </span><span style="font-size: large;"><code>increment</code></span><span style="font-size: large;"> because I used silly examples, as long as </span><span style="font-size: large;"><code>&gt;</code></span><span style="font-size: large;"> is defined as we would expect of course ;) ). I know that's quite long-winded, but re-read it a few times and you'll soon pick it up!</span></p><p><span style="font-size: large;">So what of the beast </span><span style="font-size: large;"><code>increment_answer</code></span><span style="font-size: large;"> with its type </span><span style="font-size: large;"><code>number -&gt; number -&gt; number -&gt; number</code></span><span style="font-size: large;">? Well it's the same thing again: we can give it a single </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;"> to get a function </span><span style="font-size: large;"><code>number -&gt; number -&gt; number</code></span><span style="font-size: large;"> (the same type as </span><span style="font-size: large;"><code>max</code></span><span style="font-size: large;">) which essentially has the first argument 'already filled in'. We can give it two </span><span style="font-size: large;"><code>number</code></span><span style="font-size: large;">s to get a function </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;"> which behaves as if the first two arguments are 'already filled in', or we could give it a function </span><span style="font-size: large;"><code>number -&gt; number</code></span><span style="font-size: large;"> which will 'fill in' the first argument as required and fill in the second argument with that function applied to the first. We can keep doing this, replacing values with functions and functions with values, making for a program that's applicable to a very general set of problems. As you might be thinking, Currying is a very powerful technique indeed! It's one of the reasons people get so enthused about functional programming and languages like Haskell.</span></p><p><span style="font-size: large;">OK, so that's a little functional programming basics, let's move on to more interesting things than numbers! Our programs can contain functions that do anything we want, and our entire program itself is just a function as well. So what type do programs have? </span><span style="font-size: large;"><code>void -&gt; void</code></span><span style="font-size: large;">. This is a rather rubbish type, which basically means they take in nothing and return nothing. What makes this especially worse is that a large number of programs spend a lot of time initialising themselves to start with, and backing up their calculations before they close.</span></p><p><span style="font-size: large;">The functional idea of worlds is to make programs have the type </span><span style="font-size: large;"><code>world -&gt; world</code></span><span style="font-size: large;">, which gives them an input which they can get started straight away with, rather than having to faff around with loading and parsing and such (which is made all the more difficult due to the stateless nature of the program, which is somehow accomplished by monads even though I still can't get my head around what they do), and at the end they can dump their computations straight out to the operating system for storage, rather than having to mess with IO, and all of the complexities, edge cases and breakages that entails.</span></p><p><span style="font-size: large;">Thus in this system a program to update a clock on the desktop can be as simple as:</span></p><p><span style="font-size: large;"><code>update_clock(world w) ::= new_world_from_existing(w, "clock", w.clock+1)</code></span></p><p><span style="font-size: large;">This is my own made-up syntax, but the the point is that it takes in a world, whatever that happens to be, and outputs a new world which is the same as the input except that its "clock" is '1 higher'. The point is that this is an entirely self-contained program (given the function </span><span style="font-size: large;"><code>new_world_from_existing</code></span><span style="font-size: large;">, which I only abstracted away here since I can't be arsed to specify a structure for these worlds, since it's arbitrary); the OS gives this program a world when it starts and saves the new world it passes back when it's done.</span></p><p><span style="font-size: large;">As far as the OS is concerned the worlds are just black boxes, it doesn't need to know or care what they are. When an event occurs, an OS daemon will trigger the associated programs (imagine something like Unix's cron), and these can of course trigger actions themselves (for example a clock tick can trigger a time update program, an updated time can trigger a program to render the new clock face image and having a new clock face image can trigger a screen refresh). Essentially it allows unrolling of main loops into one OS-level mechanism, and allows the programs to be short, simple, cooperative and to-the-point.</span></p><p><span style="font-size: large;">A difference between the stateful and functional world systems is that in the former, computation happens </span><span style="font-size: large;"><em>inside</em></span><span style="font-size: large;"> worlds, which capture all of the side-effects to prevent them wreaking havoc. In the latter, computation happens </span><span style="font-size: large;"><em>to</em></span><span style="font-size: large;"> worlds and new worlds are generated based on the effects of the computation; worlds are immutable and unchanging, but you can make new ones with whatever properties you like (worlds never get "replaced", although it is valid for the operating system to pass a world to a program and store the new world that is returned in the same place as the old world, as long as no other programs use the old world, but this isn't so much mutability or replacement as much as it is garbage collection; the old world is not needed any more so it is deleted, whilst some space is required for the new world which may as well be the space previously occupied by the old world).</span></p><p><span style="font-size: large;">However, the observant amongst you will have spotted by now where I'm going with this. If you've not spotted it yet then it's that these two concepts of </span><span style="font-size: large;"><em>Worlds</em></span><span style="font-size: large;"> are the same! The advantage to using worlds in an imperative, stateful language is that side-effects can be tamed, kept isolated and the APIs kept pure and side-effect free to allow more scalability and predictability. With everything wrapped up in </span><span style="font-size: large;"><em>world</em></span><span style="font-size: large;"> sandboxes, assertions about behaviour can be made which only rely upon the individual pieces of code and the little world in which they live. In other words, this stateful code behaves like pure functions which are Curried with the worlds they return!</span></p><p><span style="font-size: large;">In a functional language, worlds allow state to be passed around, so that the same small, simple functions can be used for a variety of behaviours based on the world that they take as input. In other words these pure functions behave like imperative code, just with the state being passed around explicitly!</span></p><p><span style="font-size: large;">So what does this mean? Well firstly, if we can make pure, side-effect-free imperative code then we get the awesomeness of functional code in our non-functional languages. This, admittedly, would only occur in a coarse-grained way, since there's no guarantee that anything below the API level behaves purely, but it's enough to let us build non-leaky abstractions in the way that functional languages get for free. If we have correct abstractions then we can treat them as black boxes and do all sorts of cool analysis on them, like automatic translation, optimisation, compilation, program synthesis, inter-language calls, etc.</span></p><p><span style="font-size: large;">Some of this is going on in the Viewpoints Research Institute's </span><span style="font-size: large;"><em>STEPS</em></span><span style="font-size: large;"> project, with their </span><span style="font-size: large;"><em>kernel abstractions</em></span><span style="font-size: large;">, essentially treating function calls like virtual machines, implemented as on-the-fly domain-specific language compilation in separate worlds, which makes each layer in the call stack become more sandboxed, more secure, more abstract, simpler and more specialised at its job. It's an interesting project with some cool papers floating around (although I wish they'd release their publications more often ;) )</span></p><p></p><p><span style="font-size: large;">Anyhoo, I thought I'd write a blog entry to test out KDE's Blogilo program, since Google's fail Web app POS doesn't like me, and I'm getting rather carried away with it :) Hope this works!</span></p></div>