---
title: PubSub Ahoy!
---
I've just found out about <a href="http://x60br.berlios.de/api/index.html">x60br</a> through an obscure link trek from a blog post in my feed reader. x60br is an XMPP PubSub library for Python, similar to the one I'm writing. This is teh awesome, since it means I can check what I'm doing against someone else, and possibly look into using their implementation in some areas.<br /><br />The main difference between the two (apart from the API, since mine needs to actually work before I can give it a proper API :P ) is that they handle the asynchronous nature of XMPP differently.<br /><br />In order to understand this you'll need to know a little about synchronous vs. asynchronous programming, which I've touched on before. The bits of programs which do the most work are functions. The purpose of a function is to define how to do something so that you can do it later on, for instance saying "this is how to get the items from a PubSub node" then later, when you want to get the items at a node, you can just say "get the items here" rather than having to recite every step again and again.<br /><br />In the example I just gave it could be done in two ways, synchronously or asynchronously. If it were done synchronously your program would say something like:<br /><br />def get_items(server, node):<br />&nbsp;&nbsp;&nbsp;&nbsp;items = &#091;]<br />&nbsp;&nbsp;&nbsp;&nbsp;ask_for_items(server, node)<br />&nbsp;&nbsp;&nbsp;&nbsp;reply = None<br />&nbsp;&nbsp;&nbsp;&nbsp;while reply is None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_replies()<br />&nbsp;&nbsp;&nbsp;&nbsp;for item in reply:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.append(item)<br />&nbsp;&nbsp;&nbsp;&nbsp;return items<br /><br />my_blog_posts = get_items("pubsub.jabber.org", "seriously-this-is-not-worth-reading")<br /><br />The first part DEFINES how to get the items at a node (nothing is run, it is simply a definition of what getting items means). When the last line is reached the program will request the items from the server "http://pubsub.jabber.org", then will wait for replies until it gets one and finally put every item it finds into my_blog_posts. Then the next line is run. This is a REALLY bad way of doing things in any kind of interactive, GUI-based program, since the whole program will appear to freeze whilst the reply is being waited for.<br /><br />The way around this is to make the function asynchronous. This is more complicated than the above way of doing things, but it means that your program can get on with doing other stuff (like updating progress bars, for example) whilst the routers, ISPs and servers go about sending messages to and fro so you can get the items. The way I have implemented this in my library works a little like the following:<br /><br />def get_items(server, node, completed_function):<br />&nbsp;&nbsp;&nbsp;&nbsp;stanza_id = ask_for_items(server, node)<br />&nbsp;&nbsp;&nbsp;&nbsp;assign_handler(stanza_id, completed_function)<br /><br />def assign_blog_posts(items):<br />&nbsp;&nbsp;&nbsp;&nbsp;my_blog_posts = items<br /><br />get_items("pubsub.jabber.org", "seriously-this-is-not-worth-reading", assign_blog_posts)<br /><br />This is in a simplified form (since namespaces aren't dealt with, some functions aren't defined and the reply handling mechanism isn't shown) but it gets the point across. What happens is that the request for items is still sent, but instead of waiting around for a reply before doing anything else, the program just gets on with things. When a reply IS received, the function assign_blog_posts is run, which does whatever needs to be done with the items. This is called a handler function (since it handles the replies).<br /><br />The way x60br does things is in a slightly different way. It uses the following technique:<br /><br />def get_items(server, node):<br />&nbsp;&nbsp;&nbsp;&nbsp;items = ask_for_items(server, node)<br />&nbsp;&nbsp;&nbsp;&nbsp;return items<br /><br />my_blog_posts = get_items("pubsub.jabber.org", "seriously-this-is-not-worth-reading")<br /><br />This looks the same as the synchronous way, and it is, except that it uses some clever behind-the-scenes stuff in functions like ask_for_items which makes my_blog_post get assigned straight away, letting the program carry on, except instead of assigning the items to my_blog_posts it essentially assigns a dummy. When the replies are received any instances of this dummy are changed to the actual items. This is done using the famous Twisted framework for Python.<br /><br />These are two ways of approaching the same problem (one triggers a response, one hands around an IOU), so I'll have a go at using x60br (although Twisted really seems more web servery, rather than desktop applicationy). I'll use x60br's API when modelling my own library's though, at least as a guide.<div class="blogger-post-footer"><img alt="" height="1" src="https://blogger.googleusercontent.com/tracker/2304809778837392812-8015045075859787776?l=seriously-this-is-not-worth-reading.blogspot.com" width="1" /></div>