---
title: The Ugliest Hack I've Written So Far
---
 'raise '+', '.join(&#091;t&#091;0] for t in &#091;&#091;e] for n,e in enumerate(&#091;a.expr3,a.expr2,a.expr1]) if e is not None or any(&#091;a.expr1,a.expr2,a.expr3]&#091;-(n+1):])] if (t&#091;0] is not None and t.__setitem__(0,t&#091;0].rec(i))) or (t&#091;0] is None and t.__setitem__(0, 'None')) or True]&#091;::-1])<br /><br />This is a 1-line PyMeta rule which means the following:<br /><br />Define a rule named "raise" with an amount of indentation "i", which applies to anything, which we'll call "a", as long as "a" is a type of 'Raise'. Upon finding such a thing we should output a string 'raise ' followed by the first item of every list in the set of singleton lists of   "a"'s attributes 'expr3', 'expr2' and 'expr1' when reversed which is either not equal to "None" or else comes after a non-None attribute, if the element of these lists is not None and swapping the first element for its contents recursively at the same indentation level, or if it is None then replacing it with the string "None".<br /><br />If I were writing this normally it would be something much cleaner like:<br /><br />def raise(i, a):<br />&nbsp;&nbsp;if a.__class__ == Raise:<br />&nbsp;&nbsp;&nbsp;&nbsp;to_return = 'raise '<br />&nbsp;&nbsp;&nbsp;&nbsp;attribs = &#091;a.expr3, a.expr2, a.expr1]<br />&nbsp;&nbsp;&nbsp;&nbsp;to_keep = &#091;]<br />&nbsp;&nbsp;&nbsp;&nbsp;not_end = False<br />&nbsp;&nbsp;&nbsp;&nbsp;for att in attribs:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if att is None or not_end:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_keep.append(att)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif (not att is None) and (not not_end):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_keep.append(att)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not_end = True<br />&nbsp;&nbsp;&nbsp;&nbsp;to_keep.reverse()<br />&nbsp;&nbsp;&nbsp;&nbsp;to_return = to_return+', '.join(to_keep)<br />&nbsp;&nbsp;&nbsp;&nbsp;return to_return<br /><br />but the default PyMeta grammar only allows a single line of Python in the output. Whilst the point of OMeta is that I can subclass and rewrite it to work in whatever way I want, I can't get the hang of subclassing grammars yet, and hence this mind-bending, yet at least partially elegant, functional approach.<div class="blogger-post-footer"><img alt="" height="1" src="https://blogger.googleusercontent.com/tracker/2304809778837392812-5659582638976962559?l=seriously-this-is-not-worth-reading.blogspot.com" width="1" /></div>