#!/usr/bin/env runhaskell

import Control.Applicative
import Data.List
import System.Environment
import System.Exit
import System.IO
import System.Process

-- rebuild

rebuild :: IO ExitCode
rebuild = rawSystem "./site" ["rebuild"]

-- check

watch :: IO ProcessHandle
watch = do dn <- openFile "/dev/null" WriteMode
           p  <- runProcess "./site" ["watch"] Nothing
                                               Nothing
                                               (Just dn)
                                               (Just dn)
                                               (Just dn)
           rawSystem "sleep" ["2"]
           return p

whileWatching :: IO ExitCode -> IO ExitCode
whileWatching x = do p    <- watch
                     code <- x
                     terminateProcess p
                     return code

get404s :: [String] -> [String]
get404s = let start x = "Found "       `isPrefixOf` x &&
                        "broken links" `isInfixOf`  x
              end   x = "FINISHED"     `isPrefixOf` x
           in takeWhile (not . end) . dropWhile (not . start)

crawl :: IO String
crawl = let f (ExitSuccess, _, _) = ""
            f (_,           _, e) = e
         in f <$> readProcessWithExitCode
                      "wget"
                      ["-nd", "--spider", "-e", "robots=off", "-L", "-r", "-p",
                       "http://localhost:8000"] ""

check :: IO ExitCode
check = whileWatching $ do fails <- get404s . lines <$> crawl
                           putStr $ unlines fails
                           return $ if null fails
                                       then ExitSuccess
                                       else ExitFailure 1

-- scp

scp :: IO ExitCode
scp = rawSystem "scp" ["-r", "_site", "chriswarbo.net:~/"]

-- update

update :: IO ExitCode
update = rawSystem "ssh" ["-t", "chriswarbo.net", "/home/chris/update.sh"]

-- main

exitOnFailure :: IO ExitCode -> IO ()
exitOnFailure = let f ExitSuccess = return ()
                    f code        = exitWith code
                 in (>>= f)

write x = putStrLn x

ops :: [(String, IO ExitCode)]
ops = [("rebuild", write "Rebuilding"     >> rebuild),
       ("check",   write "Checking links" >> check  ),
       ("copy",    write "Copying"        >> scp    ),
       ("update",  write "Updating"       >> update )]

op :: String -> IO ()
op n = case lookup n ops of
            Just x  -> exitOnFailure x
            Nothing -> return ()

main = getArgs >>= sequence . map op >> return ()
