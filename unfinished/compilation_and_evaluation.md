---
title: Compilation and Evaluation
---
 - Interpreters do not look at a program's expression until it's to be executed, at which point they pass it through a fixed, deterministic program to reduce it into a result, e.g. by looking up names, substituting arguments into functions, matching patterns, etc.
 - Just-in-time compilers are like interpreters, but the way they evaluate the expression is potentially unpredictable, as they may have multiple strategies with different resource usage. Interpretation has a low up-front cost but potentially costly operations; optimisation may decrease the cost of operations (e.g. by specialising operations to avoid dynamic dispatch) but has a larger up-front cost.
 - Ahead-of-time compilers look at a program's expression before it is executed, and may transform it in potentially-unpredictable ways (e.g. as a result of optimisations and their interactions). They can store this transformed expression, an 'executable', for running later, potentially many times. This amortises the up-front cost of optimisations.
 - Supercompilation is an optimisation which performs as much evaluation as possible before execution. The idea of supercompilation is to pre-calculate everything which *doesn't* depend on dynamic information, and to make any dynamic decisions as *early* as possible, so that the resulting program becomes a linear sequence of instructions. NOTE: Is this right? Perhaps it's better to *combine* dynamic decisions as much as possible, so that everything in-between is linear? Read some official definition for clarification...
 - Superoptimisation is an optimisation which replaces expressions with equivalent, faster alternatives, found using searc methods.
 - Hutter search is an evaluation strategy which concurrently runs an interpreter as well as a few search procedures. If the searchers discover an equivalent, faster alternative expression, the interpreter is aborted and the evaluation is restarted with the new expression.
