---
title: Procedural Pictures
---

<!-- Preamble -->

```{pipe="sh > /dev/null"}
mkdir -p root/data/autogenerated/procedural
ln -s root/data/autogenerated/procedural proc
```

```{pipe="tee proc/Pic.hs > /dev/null"}
module Pic where

-- Constants
scale  = 7
dim    = 2 ^ scale
pixels = [(x, y) | x <- [0..dim - 1], y <- [0..dim - 1]]

-- Types
type Bits  = [Bool]
type Pixel = (Int, Int)
type Mono  = Bool
type Grey  = Int
type RGB   = (Int, Int, Int)

-- Conversions
showMono :: Mono -> String
showMono True  = "1"
showMono False = "0"

showGrey :: Grey -> String
showGrey = show

showRGB :: RGB -> String
showRGB (r,g,b) = show r ++ " " ++ show g ++ " " ++ show b

toBits' :: Int -> Bits
toBits' 0 = [False]
toBits' 1 = [True]
toBits' n = let (d, m) = n `divMod` 2
             in toBits' m ++ toBits' d

toBits :: Int -> Bits
toBits n = take scale $ toBits' n ++ repeat False

fromBits :: Bits -> Int
fromBits []         = 0
fromBits (True :xs) = 1 + fromBits (False:xs)
fromBits (False:xs) = 2 * fromBits xs

-- Image
header :: Int -> Int -> String
header p c = unlines ["P" ++ show p,        -- Format
                      show dim,             -- Width
                      show dim,             -- Height
                      if c > 0 then show c  -- Colour range
                               else ""]

monoHeader   = header 1 0
greyHeader   = header 2 dim
colourHeader = header 3 dim

renderMono   :: (Int -> Int -> Mono) -> Pixel -> String
renderMono   f (x, y) = showMono (f x y)

renderGrey   :: (Int -> Int -> Grey) -> Pixel -> String
renderGrey   f (x, y) = showGrey (f x y)

renderColour :: (Int -> Int -> RGB)  -> Pixel -> String
renderColour f (x, y) = showRGB (f x y)

monoFrom   f = unlines $ monoHeader   : map (renderMono    f) pixels
greyFrom   f = unlines $ greyHeader   : map (renderGrey    f) pixels
colourFrom f = unlines $ colourHeader : map (renderColour  f) pixels

-- Helpers
bitWise :: (Bits -> Bits -> Bits) -> Int -> Int -> Int
bitWise f x y = fromBits (f (toBits x) (toBits y))

toRGB :: Bits -> RGB
toRGB bs = (fromBits (take scale                   bs),
            fromBits (take scale (drop      scale  bs)),
            fromBits (take scale (drop (2 * scale) bs)))

chunk :: Int -> [a] -> [[a]]
chunk 0 xs = []
chunk 1 xs = [xs]
chunk n xs = let m = length xs `div` n
              in take m xs : chunk (n - 1) (drop m xs)

hue :: Float -> (Float, Float, Float)
hue h = let (i, f) = properFraction (h * 6)
            q = (1 - f)
         in case i of
                 0 -> (1, f, 0)
                 1 -> (q, 1, 0)
                 2 -> (0, 1, f)
                 3 -> (0, q, 1)
                 4 -> (f, 0, 1)
                 5 -> (1, 0, q)

hues :: Int -> [RGB]
hues n = map (toScaleRGB . hue . (/ fromIntegral n) . fromIntegral) [0..n-1]

toScale :: Float -> Grey
toScale = floor . (fromIntegral dim *)

toScaleRGB :: (Float, Float, Float) -> RGB
toScaleRGB (x, y, z) = (toScale x, toScale y, toScale z)

cols' :: Int -> [(Float, Float, Float)]
cols' n = let n'  = n `div` 8
              xs  = map ((/ fromIntegral n') . fromIntegral) [1..n']
           in concatMap (`map` xs) [\b -> (0, 0, b),
                                    \g -> (0, g, 1),
                                    \b -> (0, 1, b),
                                    \r -> (r, 1, 0),
                                    \b -> (1, 1, b),
                                    \g -> (1, g, 1),
                                    \b -> (1, 0, b),
                                    \r -> (r, 0, 0)]

cols :: Int -> [RGB]
cols = map toScaleRGB . cols'
```

```{pipe="tee proc/monoCode > /dev/null"}
echo "import Pic"
cat
echo ""
echo "main = putStr (monoFrom f)"
```


```{pipe="tee proc/greyCode > /dev/null"}
echo "import Pic"
cat
echo ""
echo "main = putStr (greyFrom f)"
```

```{pipe="tee proc/colourCode > /dev/null"}
echo "import Pic"
cat
echo ""
echo "main = putStr (colourFrom f)"
```

```{pipe="tee proc/includePic > /dev/null"}
#!/bin/sh
convert "$1.ppm" "$1_big.png"
pngcrush "$1_big.png" "$1.png"
./root/data/scripts/file2img.sh "$1" < "$1.png" | pandoc -t json
```

```{pipe="tee proc/codeAndPic > /dev/null"}
#!/bin/sh
CODE=$(cat)

echo "$CODE" | "./$2Code" > "$1.hs"
runhaskell "$1.hs" > "$1.ppm"
echo "$CODE" | ./wrapCode .haskell >> "$1.md"
echo "" >> "$1.md"
./includePic "$1" | ./wrapCode .unwrap >> "$1.md"
pandoc -t json < "$1.md"
```

```{pipe="sh 2>&1"}
LOC=$(readlink -f root/data/scripts/wrapCode.sh)
cd proc/
ln -s "$LOC" wrapCode
chmod +x includePic *Code codeAndPic
```

I've been playing with procedurally-generated images recently; here are some interesting ones. All functions `f`{.haskell} are mapped over the pixels, taking in the x and y coordinates as bytes and returning a byte for the colour (a byte is a list of 8 `Bool`{.haskell}s).

 - [Bitwise Equality](biteq.html)
 - [One Bits](ones.html)
 - [Z-curve](z.html)
 - [Cantor Tuples](cantor.html)

<!-- Force the directory to be rebuilt whenever this changes -->
```{pipe="sh > /dev/null"}
find root/*/procedural -mmin +30 -exec touch {} \;
```
