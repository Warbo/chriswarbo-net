---
title: Cantor Tuples
---

<!-- Preamble -->

<!-- Grab the procedural image scripts from data/ -->

```{pipe="sh"}
cp -ar root/data/autogenerated/procedural/* .
echo "" > /tmp/err
```

<!-- I haven't figured out how to escape backticks in inline code yet -->

```{pipe="tee replaceTicks > /dev/null"}
#!/bin/sh
sed 's/TICK/`/g'
```

<!-- Shorthand for appending code to our main Haskell file -->

```{pipe="tee code > /dev/null"}
#!/bin/sh
echo "" >> code.hs
tee -a     code.hs
echo "" >> code.hs
```

```{pipe="sh > /dev/null"}
chmod +x code replaceTicks
```

```{pipe="./code > /dev/null"}
import           Pic
import           Data.List
import qualified Data.Map as DM
```

<!-- Content -->

Cantor pairs (and triplets, or tuples in general) are way to enumerate multi-dimensional spaces, similar to the [Z curve](z.html). Unlike the Z curve, Cantor Tuples don't preserve locality very well.

The idea is very simple: we trace a curve back and forth across the space until we've covered the whole thing. Here are the definitions we'll be using below:

 - `type Dimensions = Int`{.haskell pipe="./code"}
    - How many `Dimensions`{.haskell} to work in
 - `type Range = Int`{.haskell pipe="./code"}
    - A bounded or unbounded `Range`{.haskell} of coordinates
 - `range n = if n == 0 then [0..] else [0..n]`{.haskell pipe="./code"}
    - A way to enumerate a `Range`{.haskell}
 - `type Point = [Int]`{.haskell pipe="./code"}
    - Storing *lists* of coordinates rather than tuples lets us use any number of `Dimensions`{.haskell}
 - `type Curve = [Point]`{.haskell pipe="./code"}
    - A `Curve`{.haskell} is a line traced through the space
 - `data Shape = Shape {sDim :: Dimensions, sRange :: Range, sPred :: Point -> Bool}`{.haskell pipe="./code"}
    - We define a `Shape`{.haskell} using a *predicate*, deciding whether a `Point`{.haskell} is in the `Shape`{.haskell} or not

## Axis-aligned `Curves`{.haskell} ##

The most obvious way to trace a `Curve`{.haskell} across a `Shape`{.haskell} is to start at `(0, 0)` (which for our purposes will be the *top* left of the images) and increase, say, the `y` coordinate to get `(0, 1)`, then `(0, 2)`, etc. until we exhaust the `Shape`{.haskell}'s `Range`{.haskell}, then jump to `(1, 0)` and do the same thing, and so on:

```{.haskell pipe="./code"}
aaCurve :: Range -> Dimensions -> Curve
aaCurve r 1 = [[x]  | x <- range r]
aaCurve r n = [x:xs | x <- range r, xs <- aaCurve r (n - 1)]

aaShape :: Shape -> Curve
aaShape (Shape d r p) = filter p (aaCurve r d)
```

If we use this to trace a black-to-white gradient across a square image, we get this:

```{pipe="tee aaGrad.hs > /dev/null"}

img    = Shape 2 dim (const True)
curve  = aaShape img
white  = dim
count  = length curve
greys  = [(i * white) `div` count | i <- [0..]]
pxls   = DM.fromList $ zip curve greys

aaGrad x y = let this   = DM.lookup [x, y] pxls
              in maybe (error "Out of range") id this

```

```{pipe="sh | ./greyCode | runhaskell > aagrad.ppm"}
cat code.hs
cat aaGrad.hs
echo "f = aaGrad"
```

```{.unwrap pipe="sh"}
./includePic aagrad | ./wrapCode .unwrap | pandoc -t json
```

### A Finite Example ###

Let's say we have a `circle`{.haskell} (where `dim = 2 ^ scale =`{.haskell} `cat code.hs; echo ""; echo "main = print dim"`{.haskell pipe="sh | runhaskell"} is the width and height of the following images):

```{.haskell pipe="./code"}
pythagoras' :: Int -> Int -> Int
pythagoras' a b = a ^ 2 + b ^ 2  -- There's no need to take the square root

circle :: Shape
circle = let centre = dim `div` 2
             p [x, y] = pythagoras' (x - centre) (y - centre) < (centre ^ 2)
          in Shape 2 (2 * centre) p
```

Here's what we get by mapping `circle`{.haskell}'s predicate over the coordinates of a bunch of pixels:

```{.haskell pipe="./code"}
drawCircle x y = sPred circle [x, y]
```

```{.haskell pipe="sh | ./monoCode circ | runhaskell > circ.ppm 2>> /tmp/err"}
cat code.hs
echo ""
echo "f = drawCircle"
```

```{.unwrap pipe="sh"}
./includePic circ
```

Another thing we can do with `circle`{.haskell} is to approximate π:

 - `π * r^2`{.haskell} is the area of any circle
    - `r = dim TICKdivTICK 2`{.haskell pipe="./replaceTicks"} in our example
 - `sRange s ^ sDim s`{.haskell} is the area of the bounding box of `s :: Shape`{.haskell}
    - `sRange circle = dim = 2 * r`{.haskell}
    - `sDim   circle = 2`{.haskell}
    - `boxArea = (2 * r)^2 = 4 * r^2`{.haskell} for `circle`{.haskell}
 - `circleArea / boxArea = (π * r^2) / (4 * r^2) = π / 4`{.haskell} follows from simple algebra
    - Therefore `π = 4 * circleArea / boxArea`{.haskell pipe="./code"}
 - Since each `Point`{.haskell} is an uniform distance from its neighbours, counting how many are in a `Shape`{.haskell} is a measure of the `Shape`{.haskell}'s area
    - `aaArea     = length . aaShape`{.haskell pipe="./code"} gives us the area inside a `Shape`{.haskell}
    - `circleArea = fromIntegral $ aaArea circle`{.haskell pipe="./code"}
    - `boxArea    = fromIntegral $ aaArea (Shape (sDim circle) (sRange circle) (const True))`{.haskell pipe="./code"}
 - Plugging these values into our definition of π gives `cat code.hs; echo ""; echo "main = print π"`{.haskell pipe="sh | runhaskell 2>> /tmp/err"}
    - Increasing the radius decreases the error, since the sampling gives a less 'jagged' approximation of our circle

## An Unbounded Example ##

What happens if our `Range`{.haskell} is unbounded (ie. `range 0`{.haskell})? For example, we might define an infinitely-repeating pattern:

```{.haskell pipe="./code"}
checkerboard :: Shape
checkerboard = let f        = (`mod` 2) . (`div` 8)
                   g [x, y] = f x == f y
                in Shape 2 0 g
```

We can draw a finite section of it by mapping over the finite `Range`{.haskell} of our image:

```{.haskell pipe="./code"}
drawBoard x y = sPred checkerboard [x, y]
```

```{.haskell pipe="sh | ./monoCode board | runhaskell > board.ppm 2>> /tmp/err"}
cat code.hs
echo ""
echo "f = drawBoard"
```

```{.unwrap pipe="sh"}
./includePic board
```

Since the area of this `Shape`{.haskell} is infinite, so is the length of a `Curve`{.haskell} traced through the whole thing. However, an infinite `Curve`{.haskell} returned by `aaCurve` will *not* contain every `Point`{.haskell} in the `Shape`{.haskell}.

This is because we only add a `Point`{.haskell} from the second row once we've reached the end of the first row; since the first row never ends, we'll never add a `Point`{.haskell} from any other row!

## Diagonal Traces ##

Cantor's approach traces *diagonal* lines across the shape, from one coordinate axis to another:

 - Each `Point`{.haskell} on the `x` axis is the start of a diagonal line
 - To get from one `Point`{.haskell} in a line to the next, we decrement the `x` coordinate and increment the `y`
    - If we have more dimensions, we fix the first coordinate (ie. `x`) and recurse using the rest of the dimensions
 - Once the `x` coordinate hits `0`{.haskell}, we jump to the start of the next line

```{.haskell pipe="./code"}
-- One line between the axes
cantorLine :: Range -> Dimensions -> Curve
cantorLine 0 d = [replicate d 0]  -- The first line only ever contains the origin
cantorLine r 1 = [[r]]            -- In 1D, each "line" is just the starting point
cantorLine r d = [x:xs | x <- [r..0], xs <- cantorCurve (r-x) (d-1)]  -- Recurse

-- A full curve
cantorCurve :: Range -> Dimensions -> Curve
cantorCurve r d = concatMap (`cantorLine` d) (range r)

cantorShape :: Shape -> Curve
cantorShape (Shape d r p) = filter p (cantorCurve r d)
```

```
{pipe="sh | runhaskell"}
cat code.hs
echo ""
echo "main = print $ take 10 cantorTest"
```

 - Add all of the coordinates together to find our position in this "level"
 - Drop our first coordinate
 - Repeat to find the next levels

This gives us a sequence of indices `[I1, I2, I3, I4, ...]`, one for each dimension. The first levels are "coarser" than the later ones. We now need to find the size of these levels:

 - The finest (last) level goes up in increments of 1
 - Each other level goes up in increments of

This is what happens if we use cantorShape to trace a black-to-white gradient across a square:

```{.haskell pipe="tee cantorGrad.hs > /dev/null"}
-- This works for 2D; higher dimensions are more complicated

cantor2DTotal :: Int
cantor2DTotal = sum [1..2 * dim]

cantor2DFrac :: Float
cantor2DFrac = fromIntegral dim / fromIntegral cantor2DTotal

cantor2DPosToGrey :: Int -> Grey
cantor2DPosToGrey = toIntegral . (* cantor2DFrac) . fromIntegral

-- Get which line a point is in
cantor2DLine' a n = if n > a
                       then cantor2DLine' (a + 1) (n - a)
                       else (a, n)

cantor2DLine = cantor2dLine' 0

-- The index of a Point in a cantorCurve
cantorIndex2D :: Point -> Int
cantorIndex2D [x, y] = sum [1..x + y + 1] + y

img    = Shape 2 (2 * dim) (\[x, y] -> x < dim && y < dim)
curve  = cantorShape img
white  = dim
count  = length curve
greys  = [(i * white) `div` count | i <- [0..]]
pxls   = DM.fromList $ zip curve greys

index =

cantorGrad x y = cantor2DPosToGrey (cantorIndex2D [x, y])
```

```{pipe="tee test.hs"}

main = do print "4 1"
          print $ cantorCurve 4 1
          print "2 3"
          print $ cantorCurve 2 3

```

```
{pipe="sh | runhaskell"}
cat code.hs
echo ""
cat test.hs
```

```
{pipe="sh | ./greyCode | runhaskell > cantorgrad.ppm"}
cat code.hs
cat cantorGrad.hs
echo "f = cantorGrad"
```

```
{.unwrap pipe="sh"}
./includePic cantograd | ./wrapCode .unwrap | pandoc -t json
```

Each of these individual lists is finite: they start on the `x` axis and go diagonally until they end on the `y` axis (and so on for `z`, `w`, etc. in higher dimensions).


## Going The Other Way ##

So far we have a way to enumerate points, ie. to go from a 1D line to a space, like a 2D square. What about going the other direction, from a point to a position on the line?

We can write a function to calculate this for us directly, but for simplicity we will just look up our coordinate in the enumeration:

``

## Pretty Pictures ##

If we draw a gradient from black to white along the line traced by Cantor's method, we get an image like this (remember that most computer formats use the *top* left as `(0, 0)`):

```
{.unwrap pipe="./codeAndPic 1 grey"}
f x y = (* adjust) $ count (toBits x) + count (toBits y)

adjust = (2 ^ scale) `div` (2 * scale)

count []         = 0
count (True :xs) = 1 + count xs
count (False:xs) =     count xs
```
